# Resolve package version variables: Get the version suffix based on deployment ring, concatenated with dateStamp and commitHash
# Resolve Node version: Get version from package.json and suffix, if provided, and set 
# Resolve .csproj version: 

steps:
  - powershell: |
      "Deployment Ring = $(DeploymentRing)";
      $deploymentRing = "$(DeploymentRing)";
      $dateStamp = (Get-Date -format "yyyyMMdd");
      $commitHash = "$(Build.SourceVersion)".SubString(0,7);
      $vs = $dateStamp + "." + $commitHash;

      if ($deploymentRing.ToLowerInvariant() -ne "stable") {
        $nugetVersionSuffix = $deploymentRing + "." + $vs;
        Write-Host "##vso[task.setvariable variable=VersionSuffix;]$nugetVersionSuffix";
        "Resolved VersionSuffix = $nugetVersionSuffix";
        
        # npm uses a slightly different version suffix pattern, so calculate that separately.
        $npmVersionSuffix = $deploymentRing + "-" + $vs;
        Write-Host "##vso[task.setvariable variable=NpmVersionSuffix;]$npmVersionSuffix";
        "Resolved NpmVersionSuffix = $npmVersionSuffix";
      } 
    displayName: 'Resolve package version variables'

    # TODO: CodedExtension is only enabled for dotnet projects, this likely needs
    # refactoring when we have a sample Node coded extension to test with.
  - powershell: |
      $deploymentRing = "$(DeploymentRing)";

      if (Test-Path -Path package.json) {
        # Get existing version from package.json
        $packageJson = Get-Content package.json;
        $packageJsonData = $packageJson | ConvertFrom-Json;
        $packageVersion = $packageJsonData.version

        "VERSION PREFIX = $packageVersion";

        # Apply version suffix if provided
        if ($deploymentRing.ToLowerInvariant() -ne "stable") {
          "VERSION SUFFIX = $(NpmVersionSuffix)";
          $packageVersion += "-" + "$(NpmVersionSuffix)";
        }

        "VERSION = $packageVersion";
        Write-Host "##vso[task.setvariable variable=NpmPackageVersion;]$packageVersion";
        
        # Convert back into package.json
        $packageJsonData.version = $packageVersion;
        $packageJsonData | ConvertTo-Json |
        Out-File package.json -Encoding utf8
      } else {
        Write-Host "MISSING PACKAGE.JSON"
        exit 1
      }

    displayName: 'Resolve Node version'
    workingDirectory: $(WorkingDirectory)
    condition: ne('${{ parameters.componentType }}', 'codedExtension')

  - powershell: |
      $deploymentRing = "$(DeploymentRing)";

      if (Test-Path -Path *.nuspec) {
        # Get existing version from .nuspec
        $xml = [Xml] (Get-Content ./*.nuspec)
        $versionPrefix = [Version] $xml.Package.MetaData.Version

        "VERSION PREFIX = $versionPrefix";

        # Apply version suffix if provided
        if ($deploymentRing.ToLowerInvariant() -ne "stable") {
          "VERSION SUFFIX = $(VersionSuffix)";
          $packageVersion += "-" + "$(VersionSuffix)";
        }

        "VERSION = $packageVersion";
        Write-Host "##vso[task.setvariable variable=NugetPackageVersion;]$packageVersion";
      } else {
          Write-Host "MISSING .NUSPEC"
          exit 1
      }
    displayName: 'Resolve .nuspec version'
    workingDirectory: $(WorkingDirectory)
    condition: eq('${{ parameters.componentType }}', 'declarativeAsset')


  - task: colinsalmcorner.colinsalmcorner-buildtasks.tag-build-task.tagBuildOrRelease@0
    displayName: Tag build
    inputs: 
      tags: |
        NPM: $(NpmPackageVersion)
        NuGet: $(NugetPackageVersion)
    continueOnError: true
    condition: and(succeeded(), eq(variables['System.PullRequest.IsFork'], 'false'))